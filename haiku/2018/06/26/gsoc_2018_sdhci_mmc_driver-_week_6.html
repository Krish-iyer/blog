<!DOCTYPE html>
<html lang="en">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-167285649-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-167285649-1');
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>krish-iyer.github.ioWeek #6</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Week #6" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hello everyone! Here’s the update of week #6, in the last update we were not able to access the registers. When we tried mapping it, there were all zeros. so we knew there’s something wrong in the way we were accessing the register and in between this we got to know that qemu emulation for sdhc hardware only supports spec version 2 and 3 and the spec which we intended to implement was 4.2.Later, we got to know that this pcicmd &amp;= ~(PCI_command_memory | PCI_command_int_disable); was disabling PCI I/O decoding and ensuring that PCI_command_memory is set but it turns out that on haiku the PCI bus let the driver to decide whether what kind of support it need from the device. Which kinda should be automatic and restricted for a driver. Soon after commenting out the clearing command we got some value in the register mapping through MMUIO and that also confirmed that mapping of registers is working, that was a relief. My next objective was to detect the card some how by enabling few bits. So I thought it better and easy to use test registers without much complication." />
<meta property="og:description" content="Hello everyone! Here’s the update of week #6, in the last update we were not able to access the registers. When we tried mapping it, there were all zeros. so we knew there’s something wrong in the way we were accessing the register and in between this we got to know that qemu emulation for sdhc hardware only supports spec version 2 and 3 and the spec which we intended to implement was 4.2.Later, we got to know that this pcicmd &amp;= ~(PCI_command_memory | PCI_command_int_disable); was disabling PCI I/O decoding and ensuring that PCI_command_memory is set but it turns out that on haiku the PCI bus let the driver to decide whether what kind of support it need from the device. Which kinda should be automatic and restricted for a driver. Soon after commenting out the clearing command we got some value in the register mapping through MMUIO and that also confirmed that mapping of registers is working, that was a relief. My next objective was to detect the card some how by enabling few bits. So I thought it better and easy to use test registers without much complication." />
<link rel="canonical" href="http://localhost:4000/haiku/2018/06/26/gsoc_2018_sdhci_mmc_driver-_week_6.html" />
<meta property="og:url" content="http://localhost:4000/haiku/2018/06/26/gsoc_2018_sdhci_mmc_driver-_week_6.html" />
<meta property="og:site_name" content="krish-iyer.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-26T15:04:41+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Week #6" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-06-26T15:04:41+05:30","datePublished":"2018-06-26T15:04:41+05:30","description":"Hello everyone! Here’s the update of week #6, in the last update we were not able to access the registers. When we tried mapping it, there were all zeros. so we knew there’s something wrong in the way we were accessing the register and in between this we got to know that qemu emulation for sdhc hardware only supports spec version 2 and 3 and the spec which we intended to implement was 4.2.Later, we got to know that this pcicmd &amp;= ~(PCI_command_memory | PCI_command_int_disable); was disabling PCI I/O decoding and ensuring that PCI_command_memory is set but it turns out that on haiku the PCI bus let the driver to decide whether what kind of support it need from the device. Which kinda should be automatic and restricted for a driver. Soon after commenting out the clearing command we got some value in the register mapping through MMUIO and that also confirmed that mapping of registers is working, that was a relief. My next objective was to detect the card some how by enabling few bits. So I thought it better and easy to use test registers without much complication.","headline":"Week #6","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/haiku/2018/06/26/gsoc_2018_sdhci_mmc_driver-_week_6.html"},"url":"http://localhost:4000/haiku/2018/06/26/gsoc_2018_sdhci_mmc_driver-_week_6.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" type="text/css" href="/assets/main-light.css"></head>
<body>
    <div class="container"><header>
  <div class="menu">
    <ul><li><a href="/">/home</a></li><li><a href="/about/">/about</a></li><li><a href="/contact">/contact</a></li></ul>
  </div>
</header>
<main>
      <ul>
    <center><h1>Week #6</h1></center>
</ul>

<p>Hello everyone! Here’s the update of week #6, in the last update we were not able to access the registers. When we tried mapping it, there were all zeros. so we knew there’s something wrong in  the way we were accessing the register and in between this we got to know that <a href="https://github.com/qemu/qemu/blob/bec9c64ef7be8063f1192608b83877bc5c9ea217/hw/sd/sdhci.c#L72">qemu emulation for sdhc hardware</a> only supports <a href="https://www.sdcard.org/jp/developers/overview/host_controller/simple_spec/Simplified_SD_Host_Controller_Spec.pdf">spec version 2</a> and 3 and the spec which we intended to implement was <a href="https://www.sdcard.org/downloads/pls/pdf/index.php?p=PartA2_SD%20Host_Controller_Simplified_Specification_Ver4.20.jpg&amp;f=PartA2_SD%20Host_Controller_Simplified_Specification_Ver4.20.pdf&amp;e=EN_SSA2">4.2</a>.Later, we got to know that <a href="https://github.com/krish-iyer/haiku/blob/5abb958dec121d202e3f71450d41acff063d5393/src/add-ons/kernel/busses/mmc/sdhci_pci.cpp#L116">this</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pcicmd &amp;= ~(PCI_command_memory | PCI_command_int_disable); was disabling PCI I/O decoding and ensuring that PCI_command_memory is set but it turns out that on haiku the PCI bus let the driver to decide whether what kind of support it need from the device. Which kinda should be automatic and restricted for a driver. Soon after commenting out the clearing command we got some value in the register mapping through MMUIO and that also confirmed that mapping of registers is working, that was a relief. My next objective was to detect the card some how by enabling few bits. So I thought it better and easy to use test registers without much complication. 
</code></pre></div></div>

<p>So I enabled <strong>card detect signal</strong> and <strong>card detect test level</strong> in <em>Host Control 1</em> and checked the bits in <em>Present state 
register</em> and <em>Normal interrupt status register</em> (acc. to spec 4.2). Also, I have checked specification version 2 and was 
similar. But this configuration didn’t worked and registers didn’t responded and it seems it’s not that easy, so better we 
will try by enabling and polling interrupt registers.</p>

<p>We also made few changes in the <a href="https://github.com/krish-iyer/haiku/commit/5abb958dec121d202e3f71450d41acff063d5393">code</a> and made it <strong>slot</strong> and <strong>BAR</strong> dependant, so each node(child device) will be registered at each slot and each alot will be having a base address which will be mentioned in BAR(first_bar_index + slot). Hence, there will distinct register mapping for each slot. And on the later part each slot will be hooked to something like /dev/mmc/.. by mmc_disk driver.</p>

<p>We were trying to install the interrupt handler and tried to figure out which level of interrupt is supported by the hardware</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if
	get_msix_count() or get_msi_count() gives zero everytime and thus it means that we are left with pin-driven interrupt but there might be a possibility that we might have to enable msi in qemu. We still have to look into this.
</code></pre></div></div>

<p>In this I was also explored an interesting aspect which I haven’t looked into, thanks to PulkoMandy to bring it up. I have attached link to mail <a href="https://www.freelists.org/post/haiku-development/SDHCI-MMC-Driver-Trouble-in-Mapping-the-Registers,1">archive</a> and tried to explain. Please comment below if I have missed something or any different idea in which it could have been explained. Recently, there was also a <a href="https://github.com/qemu/qemu/commit/1e23b63f022ae79d7a5c535fe549127ad52d5ba6">commit</a> regarding register definition for sepc version 4.2 in qemu. Let’s see in this week if get card detection working.</p>


    </main><footer>
  
</footer>
</div>
  </body>
</html>
